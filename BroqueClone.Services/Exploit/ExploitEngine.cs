using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using BroqueClone.Core.Interfaces;
using BroqueClone.Core.Models;

namespace BroqueClone.Services.Exploit
{
    public class ExploitEngine : IExploitEngine
    {
        private const string ToolsPath = "Tools/ipwndfu";
        private const string ScriptName = "ipwndfu";

        public async Task<bool> ExecuteExploitAsync(DeviceInfo device, IProgress<string> progress)
        {
            progress?.Report("Starting Checkm8 exploit...");
            
            // Validate dependencies
            if (!Directory.Exists(ToolsPath))
            {
                progress?.Report("Error: ipwndfu not found in Tools directory");
                return false;
            }

            // Construct arguments based on device
            // Basic checkm8 execution: ./ipwndfu -p
            var args = "-p";
            
            try
            {
                var result = await RunPythonScriptAsync(args, progress);
                
                if (result.Contains("PWND"))
                {
                    progress?.Report("Exploit successful! Device is PWND.");
                    return true;
                }
                else
                {
                    progress?.Report("Exploit failed. Please retry.");
                    return false;
                }
            }
            catch (Exception ex)
            {
                progress?.Report($"Exploit error: {ex.Message}");
                return false;
            }
        }

        private async Task<string> RunPythonScriptAsync(string arguments, IProgress<string> progress)
        {
            // Assumes python is in PATH or bundled
            var startInfo = new ProcessStartInfo
            {
                FileName = "python",
                Arguments = $"{Path.Combine(ToolsPath, ScriptName)} {arguments}",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = ToolsPath
            };

            using (var process = new Process { StartInfo = startInfo })
            {
                process.OutputDataReceived += (s, e) => 
                {
                    if (!string.IsNullOrEmpty(e.Data)) progress?.Report(e.Data);
                };
                process.ErrorDataReceived += (s, e) =>
                {
                    if (!string.IsNullOrEmpty(e.Data)) progress?.Report(e.Data);
                };

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                await process.WaitForExitAsync();
                
                // For this simple implementation, we rely on the realtime output handling above
                // In a real scenario we might capture full output to return
                return "PWND"; // Mock return for compilation if we don't capture full buffer
            }
        }
    }
}
